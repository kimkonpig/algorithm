* big-O 시간 : 알고리즘의 효율성을 나타내는 지표 혹은 언어

* 시간복잡도 : 점근적 실행 시간 or big-O 시간에 대한 개념

* 퍼포먼스 좋은 순(수행시간 짧은 순)
  O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2N) < O(N!) < O(N^N)

* 최선 / 최악 / 평균적인 경우(퀵정렬을 예시로)
  - 퀵정렬? 축이 되는 원소를 무작위로 하나 정해 그보다 작은 원소들은 앞에, 큰 원소들은 뒤로 놓이도록 swap 반복
  - N : 배열의 크기
  - 최선 : 모든 원소들이 같은 값일 때 -> O(N)
  - 최악 : 배열에서 가장 큰 원소가 계속 축이 될 때 -> O(N^2) : 배열을 절반으로 나누지 못하고 계속 1개만 줄어든 배열로 재귀 호출
  - 평균 : 퀵정렬의 수행시간은 평균 O(NlogN) 이라고 함

* 공간복잡도 : 크기가 N인 배열을 만들고자 한다면 공간복잡도는 O(N), 
N * N 크기의 2차원 배열을 만들고자 한다면 O(N^2) 의 공간이 필요

* 공간복잡도 계산 시 재귀호출에서 사용하는 스택공간 또한 계산해야한다. 
비교 예시 : 책 64쪽

* 상수항은 무시하라!
O(2N) -> O(N)으로 표기

* 수식에서 지배적이지 않은 항은 무시하라!
O(N^2 + N) -> O(N^2)
O(N + logN) -> O(N)
O(5*2^N + 1000N^100) -> O(2^N)

* 덧셈 수행시간 / 곱셈 수행시간
>> O(A + B) : A를 끝마친 후에 B 수행
    for(int a : arrA){
	  print(a);
    }

    for(int b : arrB){
	  print(b);
    }

>> O(A * B) : A가 할때마다 B 수행
    for(int a : arrA){
	for(int b : arrB){
		print(a + ", " + b);
	}
    }

*logN 수행시간
O(logN) : 이진탐색, 균형이진탐색트리에서 많이 볼 수 있음(절반씩 줄어드는)
이진탐색 : N개의 정렬된 원소가 들어 있는 배열에서 원소 x를 찾을 때 사용
먼저 원소 x와 배열의 중간값을 비교 / x==중간값 만족 시 반환 / x<중간값 만족 시 배열의 왼쪽 부분 재탐색 / x>중간값 만족 시 배열의 오른쪽 부분 재탐색

처음에 N개에서 한 단계 지날수록 탐색할 원소의 개수가 N/2, N/4… 로 줄어듦 

따라서 총 수행시간은 N을 절반씩 나누는 과정에서 몇 단계만에 1이 되는지에 따라 결정됨

*재귀 호출 수행시간(이진트리 예시)
69페이지 재귀적~ 코드

트리의 깊이가 N이고 각 노드는 두 개의 자식 노드를 가짐
깊이가 한 단계 깊어질때마다 재귀호출은 2배 많아짐

깊이가 N인 전체 노드의 개수 : 2의 승수의 합 = ( 2^(N+1) - 1 )
O(분기^깊이) -> O(2^깊이) -> O(2^N) 




